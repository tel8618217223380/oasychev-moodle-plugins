<?php

/**
 * Language strings for the Preg question type.
 *
 * @package    qtype_preg
 * @copyright  2012 Oleg Sychev, Volgograd State Technical University
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

$string['answersinstruct'] = '<p>Enter (at least one) regular expressions in the chosen notation as answers. If a correct answer is given, it should match at least one regular expression with 100% grade.</p><p>You can use placeholders like {$0} in the feedback to insert captured parts of a student\'s response. {$0} will be replaced by the whole match, {$1} with the first subpattern match etc. If the chosen engine doesn\'t support subpattern capturing you should use only {$0}.</p>';
$string['assertfailmodeasis'] = 'Fast';
$string['assertfailmodedescription'] = 'Full mode lets the finite state automata engine work 100% correctly with simple assertions and enables support of complex assertions, but it works roughtly 2 times slower than the fast mode. Fast mode may rarely yield a wrong hint in complex regexes with \b or \B assertions.';
$string['assertfailmodelabel'] = 'Assertion support mode';
$string['assertfailmodemerge'] = 'Full';
$string['answerno'] = 'Answer {$a}';
$string['charhintpenalty'] = 'Penalty for the next character hint';
$string['charhintpenalty_help'] = 'Penalty for getting the one-character hint. Typically will be greater than usual Moodle question penalty (which applies to any new attempt to answer question without hints). These penalties are mutually exclusive.';
$string['lexemhintpenalty'] = 'Penalty for the next lexem hint';
$string['lexemhintpenalty_help'] = 'Penalty for getting the next lexem hint. Typically will be greater than usual Moodle question penalty (which applies to any new attempt to answer question without hints) and next character one. These penalties are mutually exclusive.';
$string['correctanswer'] = 'Correct answer';
$string['correctanswer_help'] = 'Enter a correct answer (not a regular expression) to be shown to students. If you leave it empty the matching engine will try to generate a correct answer itself, taking heed to get the closest one to the student\'s response. For now only finite state automata engine can generate correct answers.';
$string['debugheading'] = 'Debug settings';
$string['defaultenginedescription'] = 'Matching engine selected by default when creating a new question';
$string['defaultenginelabel'] = 'Default matching engine';
$string['defaultlangdescription'] = 'Language selected by default when creating a new question';
$string['defaultlanglabel'] = 'Default language';
$string['defaultnotationdescription'] = 'Notation selected by default when creating a new question';
$string['defaultnotationlabel'] = 'Default notation';
$string['description_tool'] = 'Description';
$string['description_tool_help'] = 'Here you can see description of regular expression. Pressing the node of the tree marks corresponding subgraph marks corresponding part of description with yellow color.';
$string['doterror'] = 'Can\'t draw {$a->name} for this regex';
$string['engine'] = 'Matching engine';
$string['engine_help'] = '<p>There is no \'best\' matching engine, so you can choose the engine that fits the particular question best.</p><p>Native <b>PHP preg matching engine</b> works using preg_match() function from PHP language. It\'s almost 100% bug-free and able to work with full PCRE syntax, but can\'t support advanced features (showing partial matches and hinting).</p><p><b>FA matching engine</b> uses custom matching code. It supports partial matching and hinting, but don\'t support lookaround assertions (you\'ll be notified when trying to save a question with unsupported expressions) and potentially can contain bugs.</p><p>If the difference between engines is too hard to you, just try them all to see how their capabilities suit your needs. If one engine fails in a question then try another engines to see if they can handle it better.</p><p>FA engine is probably the best choice if you don\'t use lookaround assertions.</p>';
$string['exactmatch'] = 'Exact matching';
$string['exactmatch_help'] = '<p>By default regular expression matching returns true if there is at least one match in the given string (answer). Exact matching means that the match must be the entire string.</p><p>Set this to Yes, if you write regular expressions for full student\'s answers. Setting this to No gives you additional flexibility: you can specify an answer with low (or zero) grade to catch common errors and give comments on them. You still can specify exact matches for some of your regular expressions if you start them with ^ and end with $.</p>';
$string['explaining_graph_tool'] = 'Explaining graph';
$string['explaining_graph_tool_help'] = 'Here you can see explaining graph. Pressing the node of the tree marks corresponding subgraph with dark green rectangle. You can also select multiple nodes at once rectangle, enabling mode selection rectangle.';
$string['fa_matcher'] = 'Finite state automata';
$string['hintcolouredstring'] = 'matched part of the response';
$string['hintgradeborder'] = 'Hint grade border';
$string['hintgradeborder_help'] = 'Answers with the grade less than the hint grade border won\'t be used in hinting.';
$string['hintnextchar'] = 'next correct character';
$string['hintnextlexem'] = 'next correct {$a}';
$string['langselect'] = 'Language';
$string['langselect_help'] = 'For next lexem hint you should choose a language, which is used to break answers down to lexemes. Each language has it own rules for lexemes. Languages are defined using \'Formal languages block\'';
$string['lexemusername'] = 'Student-visible name for lexem';
$string['lexemusername_help'] = 'Your students probably won\'t know that an atomic part of the language they learn is called <b>lexem</b>. They may prefer to call it "word" or "number" or something. You may define a name for lexem that would be shown on the "Hint next lexem" button there.';
$string['maxerrorsshowndescription'] = 'Maximum number of errors shown for each regular expression in the question editing form';
$string['maxerrorsshownlabel'] = 'Maximum number of errors shown';
$string['nocorrectanswermatch'] = 'No maximum grade regular expression matches the correct answer';
$string['nohintgradeborderpass'] = 'No answer has a grade greater or equal the hint grade border. This disables hinting.';
$string['notation'] = 'Regular expression notation';
$string['notation_help'] = '<p>You can choose the notation to enter regular expressions. If you just want to write a regular expression, please use the default, <b>Regular expression</b> notation which is very close to PCRE, but has additional error-proof capabilities. It will ignore line breaks in you expressions, allowing mild formatting.</p><p><b>Regular expression (extended)</b> notation was created for easier handling of large expressions. It will ignore non-escaped whitespace characters, that are not inside character class, and will treat as comment anything from non-escaped # to the end of string. It is equivalent to PCRE_EXTENDED option and PHP "x" modifier.</p><p><b>Moodle shortanswer</b> notation allows you to use preg as a usual Moodle shortanswer question with the hinting capability - with no need to understand regular expressions. Just copy you answers from shortanswer question. The \'*\' wildcard is supported.</p>';
$string['notation_native'] = 'Regular expression';
$string['notation_mdlshortanswer'] = 'Moodle shortanswer';
$string['notation_pcreextended'] = 'Regular expression (extended)';
$string['nosubexprcapturing'] = '{$a} engine doesn\'t support subpattern capturing, please remove placeholders (except {$0}) from the feedback or choose another engine';
$string['objectname'] = 'question';
$string['pathtodotempty'] = 'Can\'t draw {$a->name}: path to dot of graphviz is empty. Please ask your administrator to install <a href="http://www.graphviz.com">graphviz</a> and specify path to it using the \'pathtodot\' option at Administration > Server > System Paths';
$string['pathtodotincorrect'] = 'Can\'t draw {$a->name}: path to dot of graphviz is incorrect or dot can not be executed. Please ask your administrator to check if <a href="http://www.graphviz.com">graphviz</a> is installed and \'pathtodot\' option is correct at Administration > Server > System Paths';
$string['pluginname'] = 'Regular expression';
$string['pluginname_help'] = '<p>Regular expressions are a form of writing patterns to match different strings. You can use it to verify answers in two ways: an expression to match with full (usually correct) answer, or an expression to match a part of the answer (which can be used, for example, to catch common errors and give appropriate comments).</p><p>This question uses the PHP perl-compatible regular expression syntax as the default notation. There are many tutorials about creating and using regular expression, here is one <a href="http://www.phpfreaks.com/content/print/126">example</a>. You can find detailed syntax of expression here: <a href="http://www.nusphere.com/kb/phpmanual/reference.pcre.pattern.syntax.htm">php manual</a>. Note that you should neither enclose regular expression in delimiters nor specify any modifiers - Moodle will do it for you.</p><p>You can also use this question as the advanced form of shortanswer with hinting, even if you don\'t know a bit about regular expressions! Just select <b>Moodle shortanswer</b> as notation for your questions.</p>';
$string['php_preg_matcher'] = 'PHP preg extension';
$string['pluginname_link'] = 'question/type/preg';
$string['pluginnameadding'] = 'Adding a regular expression question';
$string['pluginnameediting'] = 'Editing a regular expression question';
$string['pluginnamesummary'] = 'Enter a string response from student that can be matched against several regular expressions. Shows to the student the correct part of his response. Using behaviours with multiple tries can give a hint by telling a next correct character or lexem.<br/>You can use it without knowing regular expression to get hinting by using the \'Moodle shortanswer\' notation.';
$string['questioneditingheading'] = 'Question editing settings';
$string['regex_handler'] = 'Regex handler';
$string['subexpression'] = 'Subpattern';
$string['syntax_tree_tool'] = 'Syntax tree';
$string['syntax_tree_tool_collapsing_mode'] = 'Collapsing mode';
$string['syntax_tree_tool_help'] = 'Here you can see syntax tree of you expression. Pressing the node of tree marks corresponding subtree, subgraph and corresponding part of description. You can also collapse / expand the nodes by turning on convolution.';
$string['tobecontinued'] = '...';
$string['toolargequant'] = 'Too large finite quantifier';
$string['toomanyerrors'] = '.......{$a} more errors';
$string['lazyquant'] = 'Lazy quantifiers';
$string['greedyquant'] = 'Greedy quantifiers';
$string['possessivequant'] = 'Possessive quantifiers';
$string['unallowedhint'] = 'Selected hint not allowed due to restrictions in question settings. Please set "Allow {$a} hinting" to "yes" to allow it. Selected matching engine could affect availability of hints.';
$string['ungreedyquant'] = 'Ungreedy quantifiers';
$string['unsupported'] = '{$a->nodename} in position from {$a->linefirst}:{$a->colfirst} to {$a->linelast}:{$a->collast} is not supported by {$a->engine}.';
$string['unsupportedmodifier'] = 'Error: modifier {$a->modifier} isn\'t supported by the {$a->classname}.';
$string['usehint_help'] = 'In behaviours which allow multiple tries (e.g. adaptive or interactive) show students the \'Hint next character\' button that allows to get a one-character hint with applying the \'Hint next character penalty\'. Not all matching engines support hinting.';
$string['usecharhint'] = 'Allow next character hinting';
$string['usecharhint_help'] = 'In behaviours which allow multiple tries (e.g. adaptive or interactive) show students the \'Hint next character\' button that allows to get a one-character hint with applying the \'Hint next character penalty\'. Not all matching engines support hinting.';
$string['uselexemhint'] = 'Allow next lexem (word, number, punctuation mark) hinting';
$string['uselexemhint_help'] = '<p>In behaviours which allow multiple tries (e.g. adaptive or interactive) show students the \'Hint next word\' button that allows to get a hint either completing current lexem or showing next one if lexem is complete with applying the \'Hint next lexem penalty\'. Not all matching engines support hinting.</p><p><b>Lexeme</b> is an atomic part of the language: a word, number, punctuation mark, operator etc.</p>';

/******* Abstract syntax tree nodes descriptions *******/
// Types.
$string['leaf_charset']                = 'character set';
$string['leaf_charset_one']            = 'character';
$string['leaf_charset_except']         = 'any character except';
$string['leaf_meta']                   = 'meta-character or escape-sequence';
$string['leaf_assert']                 = 'simple assertion';
$string['leaf_backref']                = 'backreference';
$string['leaf_subexpr_call']           = 'subexpression call';
$string['leaf_template']               = 'template without params';
$string['leaf_control']                = 'control sequence';
$string['leaf_options']                = 'modifier';   // TODO: remove?
$string['node_finite_quant']           = 'finite quantifier';
$string['node_infinite_quant']         = 'infinite quantifier';
$string['node_concat']                 = 'concatenation';
$string['node_alt']                    = 'alternation';
$string['node_assert']                 = 'lookaround assertion';
$string['node_subexpr']                = 'subpattern';
$string['node_cond_subexpr']           = 'conditional subpattern';
$string['node_template']               = 'template with params';
$string['node_error']                  = 'syntax error';

// Subtypes.
$string['empty_leaf_meta']             = 'emptiness';
$string['esc_b_leaf_assert']           = 'a word boundary';
$string['esc_a_leaf_assert']           = 'start of the string';
$string['small_esc_z_leaf_assert']     = 'end of the string';
$string['capital_esc_z_leaf_assert']   = 'end of the string';
$string['esc_g_leaf_assert']           = 'first matching position in the string';
$string['circumflex_leaf_assert']      = 'start of the string';
$string['dollar_leaf_assert']          = 'end of the string';
$string['accept_leaf_control']         = '';   // TODO
$string['fail_leaf_control']           = '';
$string['mark_name_leaf_control']      = '';
$string['commit_leaf_control']         = '';
$string['prune_leaf_control']          = '';
$string['skip_leaf_control']           = '';
$string['skip_name_leaf_control']      = '';
$string['then_leaf_control']           = '';
$string['cr_leaf_control']             = '';
$string['lf_leaf_control']             = '';
$string['crlf_leaf_control']           = '';
$string['anycrlf_leaf_control']        = '';
$string['any_leaf_control']            = '';
$string['bsr_anycrlf_leaf_control']    = '';
$string['bsr_unicode_leaf_control']    = '';
$string['no_start_opt_leaf_control']   = '';
$string['utf8_leaf_control']           = '';
$string['utf16_leaf_control']          = '';
$string['ucp_leaf_control']            = '';
$string['pla_node_assert']             = 'positive lookahead assert';
$string['nla_node_assert']             = 'negative lookahead assert';
$string['plb_node_assert']             = 'positive lookbehind assert';
$string['nlb_node_assert']             = 'negative lookbehind assert';
$string['subexpr_node_subexpr']        = 'subpattern';
$string['onceonly_node_subexpr']       = 'once-only subpattern';
$string['grouping_node_subexpr']       = 'grouping';
$string['subexpr_node_cond_subexpr']   = '"subpattern"-conditional subpattern';
$string['recursion_node_cond_subexpr'] = 'recursive conditional subpattern';
$string['define_node_cond_subexpr']    = '"define"-conditional subpattern';
$string['pla_node_cond_subexpr']       = 'positive lookahead conditional subpattern';
$string['nla_node_cond_subexpr']       = 'negative lookahead conditional subpattern';
$string['plb_node_cond_subexpr']       = 'positive lookbehind conditional subpattern';
$string['nlb_node_cond_subexpr']       = 'negative lookbehind conditional subpattern';

$string['unknown_error_node_error']                = 'unknown error';
$string['missing_open_paren_node_error']           = 'Syntax error: missing opening parenthesis \'(\' for the closing parenthesis in position {$a->colfirst}.';
$string['missing_template_open_paren_node_error']  = 'Syntax error: missing template opening \'(?###name<)\' for the template closing in position {$a->colfirst}.';
$string['missing_close_paren_node_error']          = 'Syntax error: missing closing parenthesis \')\' for the opening parenthesis in position {$a->colfirst}.';
$string['missing_template_close_paren_node_error'] = 'Syntax error: missing template closing \'(?###>)\' for the template opening in position {$a->colfirst}.';
$string['missing_comment_ending_node_error']       = 'Syntax error: missing closing parenthesis for the comment in position from {$a->colfirst} to {$a->collast}.';
$string['missing_condsubexpr_ending_node_error']   = 'Unclosed conditional subpattern name.';
$string['missing_callout_ending_node_error']       = 'Unclosed callout.';
$string['missing_control_ending_node_error']       = 'Missing closing parenthesis after control sequence.';
$string['missing_subexpr_name_ending_node_error']  = 'Syntax error in subpattern name';
$string['missing_brackets_for_g_node_error']       = '\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number.';
$string['missing_brackets_for_k_node_error']       = '\k is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number.';
$string['unclosed_charset_node_error']             = 'Syntax error: missing a closing bracket \']\' for the character set starting in position {$a->colfirst}.';
$string['posix_class_outside_charset_node_error']  = 'POSIX classes are not allowed outside character sets.';
$string['quantifier_without_parameter_node_error'] = 'Syntax error: quantifier in position from {$a->colfirst} to {$a->collast} doesn\'t have an operand - nothing to repeat.';
$string['incorrect_quant_range_node_error']        = 'Incorrect quantifier range in position from  {$a->colfirst} to {$a->collast}: the left border is greater than the right one.';
$string['incorrect_charset_range_node_error']      = 'Incorrect character range in position from  {$a->colfirst} to {$a->collast}: the left character is "greater" than the right one.';
$string['set_unset_same_modifier_node_error']      = 'Setting and unsetting the {$a->addinfo} modifier at the same time in position from {$a->colfirst} to {$a->collast}.';
$string['unsupported_modifier_node_error']         = 'Unknown, wrong or unsupported modifier(s): {$a->addinfo}.';
$string['unknown_unicode_property_node_error']     = 'Unknown Unicode property: {$a->addinfo}.';
$string['unknown_posix_class_node_error']          = 'Unknown POSIX class: {$a->addinfo}.';
$string['unknown_control_sequence_node_error']     = 'Unknown control sequence: {$a->addinfo}.';
$string['condsubexpr_too_much_alter_node_error']   = 'Syntax error: too many top-level alternations in the conditional subpattern in position from {$a->colfirst} to {$a->collast}. Use parentheses if you want to include alternations in yes-expr on no-expr.';
$string['condsubexpr_assert_expected_node_error']  = 'Assertion or condition expected.';
$string['condsubexpr_zero_condition_node_error']   = 'Invalid condition (?(0).';
$string['slash_at_end_of_pattern_node_error']      = 'Syntax error: \ at end of pattern.';
$string['c_at_end_of_pattern_node_error']          = 'Syntax error: \c at end of pattern.';
$string['cx_should_be_ascii_node_error']           = '\c should be followed by an ascii character.';
$string['unexisting_subexpr_node_error']           = 'Subpattern "{$a->addinfo}" does not exist.';
$string['duplicate_subexpr_names_node_error']      = 'Two named subpatterns have the same name.';
$string['different_subexpr_names_node_error']      = 'Different subpattern names for subpatterns of the same number.';
$string['subexpr_name_expected_node_error']        = 'Subpattern name expected.';
$string['unrecognized_pqh_node_error']             = 'Unrecognised character after (? or (?-';
$string['unrecognized_pqlt_node_error']            = 'Unrecognised character after (?<';
$string['unrecognized_pqp_node_error']             = 'Unrecognised character after (?P';
$string['char_code_too_big_node_error']            = 'The character code {$a->addinfo} is too big.';
$string['char_code_disallowed_node_error']         = 'Unicode code points 0xd800 ... 0xdfff are now allowed.';
$string['callout_big_number_node_error']           = 'The number {$a->addinfo} in the callout is too big, should not be greater than 255.';
$string['lnu_unsupported_node_error']              = 'Sequences \L, \l, \N{name}, \U, and \u are not supported.';
$string['unknown_template_node_error']             = 'Unknown template: {$a->addinfo}.';
$string['wrong_template_params_count_node_error']  = 'Wrong template parameters count: {$a->addinfo->expected} expected, {$a->addinfo->given} given.';

// Types and subtypes needed for authoring tools
$string['leaf_charset_neg'] = 'negative character set';
$string['leaf_charset_error'] = 'incorrect character set';

/******* Error messages *******/
$string['error_PCREincorrectregex']              = 'Incorrect regular expression - syntax error! Consult <a href="http://pcre.org/pcre.txt">PCRE documentation</a> for more information.';
$string['error_duringauthoringtool']             = 'There were errors while trying to build {$a}:';
$string['error_infiniterecursion']               = 'Regex contains infinite recursion';

/******* FA limitations *******/
$string['fa_settings_heading'] = 'Finite state automata engine settings';
$string['engine_heading_descriptions'] = 'Matching regular expressions can be time and memory consuming. These settings allow you to control limits of time and memory usage by the matching engines. Increase them when you get messages that the regular expression is too complex, but do mind your server\'s performance (you may also want to increase PHP time and memory limits). Decrease them if you get blank page when saving or running a preg question.';
$string['fa_state_limit'] = 'Automata size limit: states';
$string['fa_state_limit_description'] = 'Max number of states in FA. Tunes time and memory limits for the FA engine when matching complex regexes.';
$string['fa_transition_limit'] = 'Automata size limit: transitions';
$string['fa_transition_limit_description'] = 'Max number of transitions in FA. Tunes time and memory limits for the FA engine when matching complex regexes.';
$string['fa_simulation_state_limit'] = 'Automata simulation limit: states';
$string['fa_simulation_state_limit_description'] = 'When matching a string with a regex containing backreferences or recurion, one FA state can be reached using different paths. This means that there are several "simulation states" created for one "structural state". This settings lets you control the overall count of such simulation states.';
$string['too_large_fa'] = 'Regular expression is too complex to be matched by {$a->engine} due to the time and/or memory limits. Please try another matching engine, ask your administrator to <a href="{$a->link}">increase time and memory limits</a> or simplify you regular expression.';
$string['empty_fa'] = 'No string can be matched by this regular expression (finite automaton is empty).';

/********** Strings for authoring tools form**********************/
$string['authoring_form_page_header'] = 'Regex constructor';
$string['authoring_form_tooltip'] = 'Open regex constructor';
$string['authoring_form_charset_mode'] = 'Display mode for complex character classes:';
$string['authoring_form_charset_flags'] = 'real meaning (unified format)';
$string['authoring_form_charset_userinscription'] = 'as written in regular expressions';
$string['authoring_form_edit_header'] = 'Regular expression';
$string['authoring_form_edit_header_help'] = 'Input your regex here. You\'ll see corresponding syntax tree, explaining graph and description. Click "Update" to commit changes in the regex.';
$string['authoring_form_options_header'] = 'Matching options';
$string['authoring_form_options_header_help'] = 'Here you can tune the matching. These options will be saved in the question editing form.';
$string['authoring_form_text'] = 'Enter your regex here:';
$string['authoring_form_tree_build'] = 'Building the tree...';
$string['authoring_form_graph_build'] = 'Building the graph...';
$string['authoring_form_testing_header'] = 'Regular expression testing';
$string['authoring_form_testing_header_help'] = 'Here you can input some strings (one per line) to test your regex. After clicking "Check the string(s)" you\'ll see results on the right: matched parts are green, unmatched parts are red. Icon shows you whether given string matched entire regex (green check mark) or not (reg cross).';
$string['authoring_form_testing_textarea'] = 'Input strings to match (one per line)';
$string['authoring_form_check_strings'] = 'Check the string(s)';
$string['authoring_form_rect_selection_mode'] =  'Rectangle selection mode';
$string['authoring_form_rect_selection_select'] =  'Select';

// Strings for node description
$string['description_operand'] = 'operand';
$string['description_range'] = 'from {$a->start} to {$a->end}';
// TYPE_LEAF_META
$string['description_empty_leaf_meta'] = 'nothing';
// TYPE_LEAF_ASSERT
$string['description_esc_b_leaf_assert'] = 'a word boundary';
$string['description_esc_a_leaf_assert'] = 'start of the string';
$string['description_small_esc_z_leaf_assert'] = 'end of the string';
$string['description_capital_esc_z_leaf_assert'] = 'end of the string';
$string['description_esc_g_leaf_assert'] = 'first matching position in the string';
$string['description_circumflex_leaf_assert'] = 'start of the string';
$string['description_dollar_leaf_assert'] = 'end of the string';
$string['description_esc_b_leaf_assert_neg'] = 'not a word boundary';
// TYPE_LEAF_BACKREF
$string['description_leaf_backref'] = 'text matched by subpattern #{$a}';
$string['description_leaf_backref_name'] = 'text matched by subpattern "{$a}"';
// TYPE_LEAF_SUBEXPR_CALL
$string['description_leaf_subexpr_call'] = 'call of the subpattern #{$a}';
$string['description_leaf_subexpr_call_all'] = 'call of the whole regular expression';
$string['description_leaf_subexpr_call_name'] = 'call of the subpattern "{$a}"';
$string['description_leaf_subexpr_call_recursive'] = 'recursive call of the subpattern #{$a}';
$string['description_leaf_subexpr_call_all_recursive'] = 'recursive call of the whole regular expression';
$string['description_leaf_subexpr_call_name_recursive'] = 'recursive call of the subpattern "{$a}"';
// TYPE_LEAF_TEMPLATE
$string['description_leaf_template'] = 'template without params';
$string['description_template_word'] = 'any word';
$string['description_template_integer'] = 'any number including + or -';
$string['description_template_parens_req'] = 'text in round parentheses';
$string['description_template_parens_opt'] = 'text in round parentheses or without';
$string['description_template_brackets_req'] = 'text in square brackets';
$string['description_template_brackets_opt'] = 'text in square brackets or without';
$string['description_template_custom_parens_req'] = 'text in optional custom brackets';
$string['description_template_custom_parens_opt'] = 'text in optional custom brackets or without';
// TYPE_LEAF_CONTROL
$string['description_accept_leaf_control'] = 'force successful subpattern match';
$string['description_fail_leaf_control'] = 'force fail';
$string['description_mark_name_leaf_control'] = 'set name to {$a->name} to be passed back';
$string['description_commit_leaf_control'] = 'if the rest of the pattern does not match - overall failure, no advance of starting point';
$string['description_prune_leaf_control'] = 'if the rest of the pattern does not match - advance to next starting character';
$string['description_skip_leaf_control'] = 'if the rest of the pattern does not match - advance to current matching position';
$string['description_skip_name_leaf_control'] = 'if the rest of the pattern does not match - advance to (*MARK:{$a})';
$string['description_then_leaf_control'] = 'if the rest of the pattern does not match - backtrack to next alternation';
$string['description_cr_leaf_control'] = 'newline matches carriage return only';
$string['description_lf_leaf_control'] = 'newline matches linefeed only';
$string['description_crlf_leaf_control'] = 'newline matches carriage return followed by linefeed';
$string['description_anycrlf_leaf_control'] = 'newline matches carriage return, linefeed or carriage return followed by linefeed';
$string['description_any_leaf_control'] = 'newline matches any Unicode newline sequence';
$string['description_bsr_anycrlf_leaf_control'] = '\R matches CR, LF, or CRLF';
$string['description_bsr_unicode_leaf_control'] = '\R matches any Unicode newline sequence';
$string['description_no_start_opt_leaf_control'] = 'no start-match optimization';
$string['description_utf8_leaf_control'] = 'UTF-8 mode';
$string['description_utf16_leaf_control'] = 'UTF-16 mode';
$string['description_ucp_leaf_control'] = 'PCRE_UCP';
// TYPE_LEAF_OPTIONS
$string['description_option_i'] = 'caseless';
$string['description_unsetoption_i'] = 'case sensitive';
$string['description_option_s'] = 'dot metacharacter matches \n';
$string['description_unsetoption_s'] = 'dot metacharacter does not match \n';
$string['description_option_m'] = 'multiline matching';
$string['description_unsetoption_m'] = 'not multiline matching';
$string['description_option_x'] = 'white spaces in expression was ignored';
$string['description_unsetoption_x'] = 'white spaces in expression was not ignored';
$string['description_option_U'] = 'quantifiers ungreedy by default';
$string['description_unsetoption_U'] = 'quantifiers greedy by default';
$string['description_option_J'] = 'allow duplicate names';
$string['description_unsetoption_J'] = 'disallow duplicate names';
$string['description_leaf_options'] = '{$a}:';
// TYPE_NODE_FINITE_QUANT
$string['description_node_finite_quant'] = '{$a->firstoperand} repeated from {$a->leftborder} to {$a->rightborder} times{$a->greedy}';
$string['description_node_finite_quant_strict'] = '{$a->firstoperand} repeated {$a->leftborder} times{$a->greedy}';
$string['description_node_finite_quant_0'] = '{$a->firstoperand} repeated no more than {$a->rightborder} times or missing{$a->greedy}';
$string['description_node_finite_quant_1'] = '{$a->firstoperand} repeated no more than {$a->rightborder} times{$a->greedy}';
$string['description_node_finite_quant_01'] = '{$a->firstoperand} may be missing{$a->greedy}';
$string['description_node_finite_quant_borders_err'] = ' (incorrect quantifier borders)';
// TYPE_NODE_INFINITE_QUANT
$string['description_node_infinite_quant'] = '{$a->firstoperand} repeated at least {$a->leftborder} times{$a->greedy}';
$string['description_node_infinite_quant_0'] = '{$a->firstoperand} repeated any number of times or missing{$a->greedy}';
$string['description_node_infinite_quant_1'] = '{$a->firstoperand} repeated any number of times{$a->greedy}';
// {$a->greedy}
$string['description_quant_lazy'] = ' (lazy quantifier)';
$string['description_quant_greedy'] = '';
$string['description_quant_possessive'] = ' (possessive quantifier)';
// TYPE_NODE_CONCAT
$string['description_node_concat'] = '{$a->firstoperand} then {$a->secondoperand}';
$string['description_node_concat_wcomma'] = '{$a->firstoperand} then {$a->secondoperand}';
$string['description_node_concat_space'] = '{$a->firstoperand} {$a->secondoperand}';
$string['description_node_concat_and'] = '{$a->firstoperand} and {$a->secondoperand}';
$string['description_node_concat_short'] = '{$a->firstoperand}{$a->secondoperand}';
// TYPE_NODE_ALT
$string['description_node_alt'] = '{$a->firstoperand} or {$a->secondoperand}';
$string['description_node_alt_wcomma'] = '{$a->firstoperand} or {$a->secondoperand}';
// TYPE_NODE_ASSERT
$string['description_pla_node_assert'] = 'further text should match: [{$a->firstoperand}]';
$string['description_nla_node_assert'] = 'further text should not match: [{$a->firstoperand}]';
$string['description_plb_node_assert'] = 'preceding text should match: [{$a->firstoperand}]';
$string['description_nlb_node_assert'] = 'preceding text should not match: [{$a->firstoperand}]';
$string['description_pla_node_assert_cond'] = 'further text matches: [{$a->firstoperand}]';
$string['description_nla_node_assert_cond'] = 'further text does not match: [{$a->firstoperand}]';
$string['description_plb_node_assert_cond'] = 'preceding text matches: [{$a->firstoperand}]';
$string['description_nlb_node_assert_cond'] = 'preceding text does not match: [{$a->firstoperand}]';
// TYPE_NODE_SUBEXPR
$string['description_subexpr_node_subexpr'] = 'subpattern #{$a->number}: [ {$a->firstoperand} ]';
$string['description_subexpr_node_subexpr_name'] = 'subpattern "{$a->name}" #{$a->number}: [ {$a->firstoperand} ]';
$string['description_onceonly_node_subexpr'] = 'once checked subpattern #{$a->number}: [ {$a->firstoperand} ]';
$string['description_onceonly_node_subexpr_name'] = 'once checked subpattern "{$a->name} #{$a->number}": [ {$a->firstoperand} ]';
$string['description_grouping_node_subexpr'] = 'grouping: [ {$a->firstoperand} ]';
$string['description_duplicate_node_subexpr'] = 'grouping (reset group numbers for capturing groups in each alternation): [ {$a->firstoperand} ]';
// TYPE_NODE_COND_SUBEXPR ({$a->firstoperand} - first option; {$a->secondoperand} - second option; {$a->cond} - condition )
$string['description_subexpr_node_cond_subexpr'] = 'the subpattern #{$a->number} has been successfully matched';
$string['description_subexpr_node_cond_subexpr_name'] = 'the subpattern "{$a->name}" has been successfully matched';
$string['description_recursion_node_cond_subexpr'] = 'the pattern #{$a->number} is in recursive matching';
$string['description_recursion_node_cond_subexpr_all'] = 'the whole pattern is in recursive matching';
$string['description_recursion_node_cond_subexpr_name'] = 'the pattern "{$a->name}" is in recursive matching';
$string['description_subexpr_node_cond_subexpr_wrapper'] = 'if {$a->cond} then check: [{$a->firstoperand}]{$a->else}';
$string['description_define_node_cond_subexpr'] = 'definition of {$a->firstoperand}';
$string['description_node_cond_subexpr'] = 'if {$a->cond} then check: [{$a->firstoperand}]{$a->else}';
$string['description_node_cond_subexpr_else'] = ' else check: [{$a->secondoperand}]';
// TYPE_NODE_TEMPLATE
$string['description_node_template'] = 'template with params';
// TYPE_LEAF_CHARSET
$string['description_charset'] = 'one of the following characters: {$a->characters};';
$string['description_charset_neg'] = 'any character except the following: {$a->characters};';
$string['description_charset_neg_one'] = 'not {$a->characters}';
$string['description_charset_range'] = 'any character {$a}';
$string['description_char'] = '<span style="color:blue">{$a->char}</span>';
$string['description_char_16value'] = 'character with code 0x{$a->code}    {$a->char}';
//$string['description_charset_one'] = '{$a->characters}';
// non-printing characters
$string['description_char0'] = 'null character(NUL)';
$string['description_char1'] = 'start of header character (SOH)';
$string['description_char2'] = 'start of text character(STX)';
$string['description_char3'] = 'end of text character(ETX)';
$string['description_char4'] = 'end of transmission character(EOT)';
$string['description_char5'] = 'enquiry character(ENQ)';
$string['description_char6'] = 'acknowledgement character(ACK)';
$string['description_char7'] = 'alarm character(BEL)';
$string['description_char8'] = 'backspace character(BS)';
$string['description_char9'] = 'tabulation(HT)';
$string['description_charA'] = 'line feed(LF)';
$string['description_charB'] = 'vertical tabulation(VT)'; // TODO - \v already has a string but this string is used when user type \xb ?
$string['description_charC'] = 'form feed(FF)';
$string['description_charD'] = 'carriage return character(CR)';
$string['description_charE'] = 'shift out character (SO)';
$string['description_charF'] = 'shift in character (SI)';
$string['description_char10'] = 'data link escape character (DLE)';
$string['description_char11'] = 'device control 1 (oft. XON) character (DC1)';
$string['description_char12'] = 'device control 2 character (DC2)';
$string['description_char13'] = 'device control 3 (oft. XOFF) character (DC3)';
$string['description_char14'] = 'device control 4 character (DC4)';
$string['description_char15'] = 'negative acknowledgement character (NAK)';
$string['description_char16'] = 'synchronous idle character (SYN)';
$string['description_char17'] = 'end of transmission block character (ETB)';
$string['description_char18'] = 'cancel character (CAN)';
$string['description_char19'] = 'end of medium character (EM)';
$string['description_char1A'] = 'substitute character (SUB)';
$string['description_char1B'] = 'escape(ESC)';
$string['description_char1C'] = 'file separator character (FS)';
$string['description_char1D'] = 'group separator character (GS)';
$string['description_char1E'] = 'record separator character (RS)';
$string['description_char1F'] = 'unit separator character (US)';
$string['description_char20'] = 'space';
$string['description_char7F'] = 'delete character (DEL)';
$string['description_charA0'] = 'non-breaking space';
$string['description_charAD'] = 'soft hyphen character';
$string['description_char2002'] = 'en space';
$string['description_char2003'] = 'em space';
$string['description_char2009'] = 'thin space';
$string['description_char200C'] = 'zero width non-joiner';
$string['description_char200D'] = 'zero width joiner';
//CHARSET FLAGS
$string['description_charflag_dot'] = 'any character';
$string['description_charflag_slashd'] = 'a decimal digit';
$string['description_charflag_slashh'] = 'a horizontal white space character';
$string['description_charflag_slashs'] = 'a white space';
$string['description_charflag_slashv'] = 'a vertical white space character';
$string['description_charflag_slashw'] = 'a word character';
$string['description_charflag_slashd_neg'] = 'not a decimal digit';
$string['description_charflag_slashh_neg'] = 'not a horizontal white space character';
$string['description_charflag_slashs_neg'] = 'not a white space';
$string['description_charflag_slashv_neg'] = 'not a vertical white space character';
$string['description_charflag_slashw_neg'] = 'not a word character';
// POSIX flags
$string['description_charflag_alnum'] = 'a letter or digit';
$string['description_charflag_alpha'] = 'a letter';
$string['description_charflag_ascii'] = 'a character with codes 0-127';
$string['description_charflag_blank'] = 'a space or tab only';
$string['description_charflag_cntrl'] = 'a control character';
$string['description_charflag_digit'] = 'a decimal digit';
$string['description_charflag_graph'] = 'a printing character (excluding space)';
$string['description_charflag_lower'] = 'a lower case letter';
$string['description_charflag_print'] = 'a printing character (including space)';
$string['description_charflag_punct'] = 'a printing character (excluding letters and digits and space)';
$string['description_charflag_space'] = 'a white space';
$string['description_charflag_upper'] = 'an upper case letter';
$string['description_charflag_word'] = 'a word character';
$string['description_charflag_xdigit'] = 'a hexadecimal digit';
// POSIX flags - negative
$string['description_charflag_alnum_neg'] = 'not a letter and not digit';
$string['description_charflag_alpha_neg'] = 'not a letter';
$string['description_charflag_ascii_neg'] = 'not a character with codes 0-127';
$string['description_charflag_blank_neg'] = 'not a space and not tab';
$string['description_charflag_cntrl_neg'] = 'not a control character';
$string['description_charflag_digit_neg'] = 'not a decimal digit';
$string['description_charflag_graph_neg'] = 'not a printing character (excluding space)';
$string['description_charflag_lower_neg'] = 'not a lower case letter';
$string['description_charflag_print_neg'] = 'not a printing character (including space)';
$string['description_charflag_punct_neg'] = 'not a printing character (excluding letters and digits and space)';
$string['description_charflag_space_neg'] = 'not a white space';
$string['description_charflag_upper_neg'] = 'not an upper case letter';
$string['description_charflag_word_neg'] = 'not a word character';
$string['description_charflag_xdigit_neg'] = 'not a hexadecimal digit';
// Unicode flags
$string['description_charflag_Cc'] = 'control';
$string['description_charflag_Cf'] = 'format';
$string['description_charflag_Cn'] = 'unassigned';
$string['description_charflag_Co'] = 'private use';
$string['description_charflag_Cs'] = 'surrogate';
$string['description_charflag_C'] = 'other Unicode property';
$string['description_charflag_Ll'] = 'lower case letter';
$string['description_charflag_Lm'] = 'modifier letter';
$string['description_charflag_Lo'] = 'other letter';
$string['description_charflag_Lt'] = 'title case letter';
$string['description_charflag_Lu'] = 'upper case letter';
$string['description_charflag_L'] = 'letter';
$string['description_charflag_Mc'] = 'spacing mark';
$string['description_charflag_Me'] = 'enclosing mark';
$string['description_charflag_Mn'] = 'non-spacing mark';
$string['description_charflag_M'] = 'mark';
$string['description_charflag_Nd'] = 'decimal number';
$string['description_charflag_Nl'] = 'letter number';
$string['description_charflag_No'] = 'other number';
$string['description_charflag_N'] = 'number';
$string['description_charflag_Pc'] = 'connector punctuation';
$string['description_charflag_Pd'] = 'dash punctuation';
$string['description_charflag_Pe'] = 'close punctuation';
$string['description_charflag_Pf'] = 'final punctuation';
$string['description_charflag_Pi'] = 'initial punctuation';
$string['description_charflag_Po'] = 'other punctuation';
$string['description_charflag_Ps'] = 'open punctuation';
$string['description_charflag_P'] = 'punctuation';
$string['description_charflag_Sc'] = 'currency symbol';
$string['description_charflag_Sk'] = 'modifier symbol';
$string['description_charflag_Sm'] = 'mathematical symbol';
$string['description_charflag_So'] = 'other symbol';
$string['description_charflag_S'] = 'symbol';
$string['description_charflag_Zl'] = 'line separator';
$string['description_charflag_Zp'] = 'paragraph separator';
$string['description_charflag_Zs'] = 'space separator';
$string['description_charflag_Z'] = 'separator';
$string['description_charflag_Xan'] = 'any alphanumeric character';
$string['description_charflag_Xps'] = 'any POSIX space character';
$string['description_charflag_Xsp'] = 'any Perl space character';
$string['description_charflag_Xwd'] = 'any Perl "word" character';
$string['description_charflag_Arabic'] = 'Arabic character';
$string['description_charflag_Armenian'] = 'Armenian character';
$string['description_charflag_Avestan'] = 'Avestan character';
$string['description_charflag_Balinese'] = 'Balinese character';
$string['description_charflag_Bamum'] = 'Bamum character';
$string['description_charflag_Bengali'] = 'Bengali character';
$string['description_charflag_Bopomofo'] = 'Bopomofo character';
$string['description_charflag_Braille'] = 'Braille character';
$string['description_charflag_Buginese'] = 'Buginese character';
$string['description_charflag_Buhid'] = 'Buhid character';
$string['description_charflag_Canadian_Aboriginal'] = 'Canadian Aboriginal character';
$string['description_charflag_Carian'] = 'Carian character';
$string['description_charflag_Cham'] = 'Cham character';
$string['description_charflag_Cherokee'] = 'Cherokee character';
$string['description_charflag_Common'] = 'Common character';
$string['description_charflag_Coptic'] = 'Coptic character';
$string['description_charflag_Cuneiform'] = 'Cuneiform character';
$string['description_charflag_Cypriot'] = 'Cypriot character';
$string['description_charflag_Cyrillic'] = 'Cyrillic character';
$string['description_charflag_Deseret'] = 'Deseret character';
$string['description_charflag_Devanagari'] = 'Devanagari character';
$string['description_charflag_Egyptian_Hieroglyphs'] = 'Egyptian Hieroglyphs character';
$string['description_charflag_Ethiopic'] = 'Ethiopic character';
$string['description_charflag_Georgian'] = 'Georgian character';
$string['description_charflag_Glagolitic'] = 'Glagolitic character';
$string['description_charflag_Gothic'] = 'Gothic character';
$string['description_charflag_Greek'] = 'Greek character';
$string['description_charflag_Gujarati'] = 'Gujarati character';
$string['description_charflag_Gurmukhi'] = 'Gurmukhi character';
$string['description_charflag_Han'] = 'Han character';
$string['description_charflag_Hangul'] = 'Hangul character';
$string['description_charflag_Hanunoo'] = 'Hanunoo character';
$string['description_charflag_Hebrew'] = 'Hebrew character';
$string['description_charflag_Hiragana'] = 'Hiragana character';
$string['description_charflag_Imperial_Aramaic'] = 'Imperial Aramaic character';
$string['description_charflag_Inherited'] = 'Inherited character';
$string['description_charflag_Inscriptional_Pahlavi'] = 'Inscriptional Pahlavi character';
$string['description_charflag_Inscriptional_Parthian'] = 'Inscriptional Parthian character';
$string['description_charflag_Javanese'] = 'Javanese character';
$string['description_charflag_Kaithi'] = 'Kaithi character';
$string['description_charflag_Kannada'] = 'Kannada character';
$string['description_charflag_Katakana'] = 'Katakana character';
$string['description_charflag_Kayah_Li'] = 'Kayah Li character';
$string['description_charflag_Kharoshthi'] = 'Kharoshthi character';
$string['description_charflag_Khmer'] = 'Khmer character';
$string['description_charflag_Lao'] = 'Lao character';
$string['description_charflag_Latin'] = 'Latin character';
$string['description_charflag_Lepcha'] = 'Lepcha character';
$string['description_charflag_Limbu'] = 'Limbu character';
$string['description_charflag_Linear_B'] = 'Linear B character';
$string['description_charflag_Lisu'] = 'Lisu character';
$string['description_charflag_Lycian'] = 'Lycian character';
$string['description_charflag_Lydian'] = 'Lydian character';
$string['description_charflag_Malayalam'] = 'Malayalam character';
$string['description_charflag_Meetei_Mayek'] = 'Meetei Mayek character';
$string['description_charflag_Mongolian'] = 'Mongolian character';
$string['description_charflag_Myanmar'] = 'Myanmar character';
$string['description_charflag_New_Tai_Lue'] = 'New Tai Lue character';
$string['description_charflag_Nko'] = 'Nko character';
$string['description_charflag_Ogham'] = 'Ogham character';
$string['description_charflag_Old_Italic'] = 'Old Italic character';
$string['description_charflag_Old_Persian'] = 'Old Persian character';
$string['description_charflag_Old_South_Arabian'] = 'Old South_Arabian character';
$string['description_charflag_Old_Turkic'] = 'Old_Turkic character';
$string['description_charflag_Ol_Chiki'] = 'Ol_Chiki character';
$string['description_charflag_Oriya'] = 'Oriya character';
$string['description_charflag_Osmanya'] = 'Osmanya character';
$string['description_charflag_Phags_Pa'] = 'Phags_Pa character';
$string['description_charflag_Phoenician'] = 'Phoenician character';
$string['description_charflag_Rejang'] = 'Rejang character';
$string['description_charflag_Runic'] = 'Runic character';
$string['description_charflag_Samaritan'] = 'Samaritan character';
$string['description_charflag_Saurashtra'] = 'Saurashtra character';
$string['description_charflag_Shavian'] = 'Shavian character';
$string['description_charflag_Sinhala'] = 'Sinhala character';
$string['description_charflag_Sundanese'] = 'Sundanese character';
$string['description_charflag_Syloti_Nagri'] = 'Syloti_Nagri character';
$string['description_charflag_Syriac'] = 'Syriac character';
$string['description_charflag_Tagalog'] = 'Tagalog character';
$string['description_charflag_Tagbanwa'] = 'Tagbanwa character';
$string['description_charflag_Tai_Le'] = 'Tai_Le character';
$string['description_charflag_Tai_Tham'] = 'Tai_Tham character';
$string['description_charflag_Tai_Viet'] = 'Tai_Viet character';
$string['description_charflag_Tamil'] = 'Tamil character';
$string['description_charflag_Telugu'] = 'Telugu character';
$string['description_charflag_Thaana'] = 'Thaana character';
$string['description_charflag_Thai'] = 'Thai character';
$string['description_charflag_Tibetan'] = 'Tibetan character';
$string['description_charflag_Tifinagh'] = 'Tifinagh character';
$string['description_charflag_Ugaritic'] = 'Ugaritic character';
$string['description_charflag_Vai'] = 'Vai character';
$string['description_charflag_Yi'] = 'Yi character';
// Unicode flags - negative
$string['description_charflag_Cc_neg'] = 'not control';
$string['description_charflag_Cf_neg'] = 'not format';
$string['description_charflag_Cn_neg'] = 'not unassigned';
$string['description_charflag_Co_neg'] = 'not private use';
$string['description_charflag_Cs_neg'] = 'not surrogate';
$string['description_charflag_C_neg'] = 'not other Unicode property';
$string['description_charflag_Ll_neg'] = 'not lower case letter';
$string['description_charflag_Lm_neg'] = 'not modifier letter';
$string['description_charflag_Lo_neg'] = 'not other letter';
$string['description_charflag_Lt_neg'] = 'not title case letter';
$string['description_charflag_Lu_neg'] = 'not upper case letter';
$string['description_charflag_L_neg'] = 'not letter';
$string['description_charflag_Mc_neg'] = 'not spacing mark';
$string['description_charflag_Me_neg'] = 'not enclosing mark';
$string['description_charflag_Mn_neg'] = 'not non-spacing mark';
$string['description_charflag_M_neg'] = 'not mark';
$string['description_charflag_Nd_neg'] = 'not decimal number';
$string['description_charflag_Nl_neg'] = 'not letter number';
$string['description_charflag_No_neg'] = 'not other number';
$string['description_charflag_N_neg'] = 'not number';
$string['description_charflag_Pc_neg'] = 'not connector punctuation';
$string['description_charflag_Pd_neg'] = 'not dash punctuation';
$string['description_charflag_Pe_neg'] = 'not close punctuation';
$string['description_charflag_Pf_neg'] = 'not final punctuation';
$string['description_charflag_Pi_neg'] = 'not initial punctuation';
$string['description_charflag_Po_neg'] = 'not other punctuation';
$string['description_charflag_Ps_neg'] = 'not open punctuation';
$string['description_charflag_P_neg'] = 'not punctuation';
$string['description_charflag_Sc_neg'] = 'not currency symbol';
$string['description_charflag_Sk_neg'] = 'not modifier symbol';
$string['description_charflag_Sm_neg'] = 'not mathematical symbol';
$string['description_charflag_So_neg'] = 'not other symbol';
$string['description_charflag_S_neg'] = 'not symbol';
$string['description_charflag_Zl_neg'] = 'not line separator';
$string['description_charflag_Zp_neg'] = 'not paragraph separator';
$string['description_charflag_Zs_neg'] = 'not space separator';
$string['description_charflag_Z_neg'] = 'not separator';
$string['description_charflag_Xan_neg'] = 'not any alphanumeric character';
$string['description_charflag_Xps_neg'] = 'not any POSIX space character';
$string['description_charflag_Xsp_neg'] = 'not any Perl space character';
$string['description_charflag_Xwd_neg'] = 'not any Perl "word" character';
$string['description_charflag_Arabic_neg'] = 'not Arabic character';
$string['description_charflag_Armenian_neg'] = 'not Armenian character';
$string['description_charflag_Avestan_neg'] = 'not Avestan character';
$string['description_charflag_Balinese_neg'] = 'not Balinese character';
$string['description_charflag_Bamum_neg'] = 'not Bamum character';
$string['description_charflag_Bengali_neg'] = 'not Bengali character';
$string['description_charflag_Bopomofo_neg'] = 'not Bopomofo character';
$string['description_charflag_Braille_neg'] = 'not Braille character';
$string['description_charflag_Buginese_neg'] = 'not Buginese character';
$string['description_charflag_Buhid_neg'] = 'not Buhid character';
$string['description_charflag_Canadian_Aboriginal_neg'] = 'not Canadian Aboriginal character';
$string['description_charflag_Carian_neg'] = 'not Carian character';
$string['description_charflag_Cham_neg'] = 'not Cham character';
$string['description_charflag_Cherokee_neg'] = 'not Cherokee character';
$string['description_charflag_Common_neg'] = 'not Common character';
$string['description_charflag_Coptic_neg'] = 'not Coptic character';
$string['description_charflag_Cuneiform_neg'] = 'not Cuneiform character';
$string['description_charflag_Cypriot_neg'] = 'not Cypriot character';
$string['description_charflag_Cyrillic_neg'] = 'not Cyrillic character';
$string['description_charflag_Deseret_neg'] = 'not Deseret character';
$string['description_charflag_Devanagari_neg'] = 'not Devanagari character';
$string['description_charflag_Egyptian_Hieroglyphs_neg'] = 'not Egyptian Hieroglyphs character';
$string['description_charflag_Ethiopic_neg'] = 'not Ethiopic character';
$string['description_charflag_Georgian_neg'] = 'not Georgian character';
$string['description_charflag_Glagolitic_neg'] = 'not Glagolitic character';
$string['description_charflag_Gothic_neg'] = 'not Gothic character';
$string['description_charflag_Greek_neg'] = 'not Greek character';
$string['description_charflag_Gujarati_neg'] = 'not Gujarati character';
$string['description_charflag_Gurmukhi_neg'] = 'not Gurmukhi character';
$string['description_charflag_Han_neg'] = 'not Han character';
$string['description_charflag_Hangul_neg'] = 'not Hangul character';
$string['description_charflag_Hanunoo_neg'] = 'not Hanunoo character';
$string['description_charflag_Hebrew_neg'] = 'not Hebrew character';
$string['description_charflag_Hiragana_neg'] = 'not Hiragana character';
$string['description_charflag_Imperial_Aramaic_neg'] = 'not Imperial Aramaic character';
$string['description_charflag_Inherited_neg'] = 'not Inherited character';
$string['description_charflag_Inscriptional_Pahlavi_neg'] = 'not Inscriptional Pahlavi character';
$string['description_charflag_Inscriptional_Parthian_neg'] = 'not Inscriptional Parthian character';
$string['description_charflag_Javanese_neg'] = 'not Javanese character';
$string['description_charflag_Kaithi_neg'] = 'not Kaithi character';
$string['description_charflag_Kannada_neg'] = 'not Kannada character';
$string['description_charflag_Katakana_neg'] = 'not Katakana character';
$string['description_charflag_Kayah_Li_neg'] = 'not Kayah Li character';
$string['description_charflag_Kharoshthi_neg'] = 'not Kharoshthi character';
$string['description_charflag_Khmer_neg'] = 'not Khmer character';
$string['description_charflag_Lao_neg'] = 'not Lao character';
$string['description_charflag_Latin_neg'] = 'not Latin character';
$string['description_charflag_Lepcha_neg'] = 'not Lepcha character';
$string['description_charflag_Limbu_neg'] = 'not Limbu character';
$string['description_charflag_Linear_B_neg'] = 'not Linear B character';
$string['description_charflag_Lisu_neg'] = 'not Lisu character';
$string['description_charflag_Lycian_neg'] = 'not Lycian character';
$string['description_charflag_Lydian_neg'] = 'not Lydian character';
$string['description_charflag_Malayalam_neg'] = 'not Malayalam character';
$string['description_charflag_Meetei_Mayek_neg'] = 'not Meetei Mayek character';
$string['description_charflag_Mongolian_neg'] = 'not Mongolian character';
$string['description_charflag_Myanmar_neg'] = 'not Myanmar character';
$string['description_charflag_New_Tai_Lue_neg'] = 'not New Tai Lue character';
$string['description_charflag_Nko_neg'] = 'not Nko character';
$string['description_charflag_Ogham_neg'] = 'not Ogham character';
$string['description_charflag_Old_Italic_neg'] = 'not Old Italic character';
$string['description_charflag_Old_Persian_neg'] = 'not Old Persian character';
$string['description_charflag_Old_South_Arabian_neg'] = 'not Old South_Arabian character';
$string['description_charflag_Old_Turkic_neg'] = 'not Old_Turkic character';
$string['description_charflag_Ol_Chiki_neg'] = 'not Ol_Chiki character';
$string['description_charflag_Oriya_neg'] = 'not Oriya character';
$string['description_charflag_Osmanya_neg'] = 'not Osmanya character';
$string['description_charflag_Phags_Pa_neg'] = 'not Phags_Pa character';
$string['description_charflag_Phoenician_neg'] = 'not Phoenician character';
$string['description_charflag_Rejang_neg'] = 'not Rejang character';
$string['description_charflag_Runic_neg'] = 'not Runic character';
$string['description_charflag_Samaritan_neg'] = 'not Samaritan character';
$string['description_charflag_Saurashtra_neg'] = 'not Saurashtra character';
$string['description_charflag_Shavian_neg'] = 'not Shavian character';
$string['description_charflag_Sinhala_neg'] = 'not Sinhala character';
$string['description_charflag_Sundanese_neg'] = 'not Sundanese character';
$string['description_charflag_Syloti_Nagri_neg'] = 'not Syloti_Nagri character';
$string['description_charflag_Syriac_neg'] = 'not Syriac character';
$string['description_charflag_Tagalog_neg'] = 'not Tagalog character';
$string['description_charflag_Tagbanwa_neg'] = 'not Tagbanwa character';
$string['description_charflag_Tai_Le_neg'] = 'not Tai_Le character';
$string['description_charflag_Tai_Tham_neg'] = 'not Tai_Tham character';
$string['description_charflag_Tai_Viet_neg'] = 'not Tai_Viet character';
$string['description_charflag_Tamil_neg'] = 'not Tamil character';
$string['description_charflag_Telugu_neg'] = 'not Telugu character';
$string['description_charflag_Thaana_neg'] = 'not Thaana character';
$string['description_charflag_Thai_neg'] = 'not Thai character';
$string['description_charflag_Tibetan_neg'] = 'not Tibetan character';
$string['description_charflag_Tifinagh_neg'] = 'not Tifinagh character';
$string['description_charflag_Ugaritic_neg'] = 'not Ugaritic character';
$string['description_charflag_Vai_neg'] = 'not Vai character';
$string['description_charflag_Yi_neg'] = 'not Yi character';
// description errors
$string['description_errorbefore'] = '<span style="color:red">';
$string['description_errorafter'] = '</span>';

// Strings for explaining graph
$string['explain_define'] = 'TODO';
$string['explain_unknow_meta'] = 'unknown meta';
$string['explain_any_char'] = 'Any character from';
$string['explain_any_char_except'] = 'Any character except';
$string['explain_begin'] = 'begin';
$string['explain_end'] = 'end';
$string['explain_true'] = 'true';
$string['explain_false'] = 'false';
$string['explain_this'] = 'this';
